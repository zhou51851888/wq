<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>周老师围棋教室 - 深度思考AI版</title>
    <style>
        body { background-color: #f0f0f0; display: flex; flex-direction: column; align-items: center; font-family: "Microsoft YaHei", sans-serif; }
        h1 { color: #333; margin-bottom: 10px; }
        .game-container { position: relative; box-shadow: 0 10px 20px rgba(0,0,0,0.3); border-radius: 4px; }
        canvas { background-color: #e3c086; cursor: pointer; display: block; }
        .info-panel { margin-top: 15px; display: flex; gap: 15px; align-items: center; }
        .btn { padding: 8px 15px; background-color: #4CAF50; color: white; border: none; cursor: pointer; border-radius: 4px; font-size: 16px; transition: background-color 0.3s; }
        .btn.secondary { background-color: #2196F3; }
        .btn.tertiary { background-color: #ff9800; }
        .btn:hover { opacity: 0.9; }
        .status { font-weight: bold; font-size: 18px; min-width: 180px; text-align: center;}
    </style>
</head>
<body>

    <h1>围棋练习 (19路 - 深度思考AI)</h1>
    
    <audio id="bgMusic" loop src="https://sf3-cdn-tos.douyinstatic.com/obj/ies-music/1657530635316231.mp3"></audio>

    <div class="game-container">
        <canvas id="goBoard" width="600" height="600"></canvas>
    </div>
    <div class="info-panel">
        <div class="status">请执黑先行</div>
        <button class="btn" onclick="game.resetGame()">重新开始</button>
        <button class="btn secondary" onclick="game.toggleAI()" id="aiBtn">切换模式：双人对战</button>
        <button class="btn tertiary" id="musicBtn" onclick="toggleMusic()">播放音乐</button>
    </div>

<script>
// --- 音乐控制逻辑 ---
const bgMusic = document.getElementById('bgMusic');
const musicBtn = document.getElementById('musicBtn');
let isMusicPlaying = false;
function toggleMusic() {
    if (isMusicPlaying) {
        bgMusic.pause();
        musicBtn.innerText = '播放音乐';
    } else {
        bgMusic.play().catch(e => console.log("音乐播放失败:", e));
        musicBtn.innerText = '静音';
    }
    isMusicPlaying = !isMusicPlaying;
}

class GoGame {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.gridSize = 19;
        this.boardSize = 600;
        this.cellSize = (this.boardSize - 60) / (this.gridSize - 1);
        this.clickSound = new Audio('https://actions.google.com/sounds/v1/impacts/stone_on_wood_plank.ogg');
        this.isAIEnabled = true;
        this.init();
        this.canvas.addEventListener('mousedown', (e) => this.handleInput(e));
        this.updateAIModeButton();
    }

    init() {
        this.board = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
        this.currentColor = 1; 
        this.history = [];
        this.draw();
        this.updateStatus();
    }
    
    updateAIModeButton() {
        document.getElementById('aiBtn').innerText = this.isAIEnabled ? "模式：人机对战(带提示)" : "模式：双人对战";
    }

    toggleAI() {
        this.isAIEnabled = !this.isAIEnabled;
        this.updateAIModeButton();
        this.resetGame();
    }

    draw() {
        // ... (绘制代码与之前版本相同，为简洁省略)
        this.ctx.clearRect(0, 0, this.boardSize, this.boardSize);
        this.ctx.fillStyle = '#e3c086'; this.ctx.fillRect(0, 0, this.boardSize, this.boardSize);
        this.ctx.beginPath(); this.ctx.strokeStyle = '#000';
        for (let i = 0; i < this.gridSize; i++) {
            const p = 30 + i * this.cellSize;
            this.ctx.moveTo(30, p); this.ctx.lineTo(this.boardSize - 30, p);
            this.ctx.moveTo(p, 30); this.ctx.lineTo(p, this.boardSize - 30);
        }
        this.ctx.stroke();
        [3, 9, 15].forEach(r => [3, 9, 15].forEach(c => {
            this.ctx.beginPath(); this.ctx.arc(30 + c * this.cellSize, 30 + r * this.cellSize, 4, 0, 2 * Math.PI);
            this.ctx.fillStyle = '#000'; this.ctx.fill();
        }));

        for (let y = 0; y < this.gridSize; y++) for (let x = 0; x < this.gridSize; x++) if (this.board[y][x]) this.drawStone(x, y, this.board[y][x]);
        
        if (this.isAIEnabled && this.currentColor === 1) {
            this.displayLibertyHints();
        }

        if (this.history.length > 0) {
            const last = this.history[this.history.length-1];
            this.ctx.strokeStyle = 'red'; this.ctx.lineWidth = 2;
            this.ctx.strokeRect(30 + last.x*this.cellSize - this.cellSize/2, 30 + last.y*this.cellSize - this.cellSize/2, this.cellSize, this.cellSize);
            this.ctx.lineWidth = 1;
        }
    }

    displayLibertyHints() {
        // ... (提示代码与之前版本相同，为简洁省略)
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        const visited = new Set();
        for (let y = 0; y < this.gridSize; y++) {
            for (let x = 0; x < this.gridSize; x++) {
                const key = `${x},${y}`;
                if (this.board[y][x] !== 0 && !visited.has(key)) {
                    const color = this.board[y][x];
                    const group = this.getGroup(x, y, color, this.board);
                    group.stones.forEach(stone => visited.add(`${stone[0]},${stone[1]}`));
                    if (group.stones.length > 0) {
                        const avgX = group.stones.reduce((sum, s) => sum + s[0], 0) / group.stones.length;
                        const avgY = group.stones.reduce((sum, s) => sum + s[1], 0) / group.stones.length;
                        const canvasX = 30 + avgX * this.cellSize;
                        const canvasY = 30 + avgY * this.cellSize;
                        this.ctx.fillStyle = (color === 1) ? '#63E6BE' : '#FF6B6B';
                        this.ctx.fillText(group.liberties, canvasX, canvasY);
                    }
                }
            }
        }
    }

    drawStone(x, y, color) {
        // ... (绘制代码与之前版本相同，为简洁省略)
        const cx = 30 + x * this.cellSize, cy = 30 + y * this.cellSize;
        this.ctx.beginPath(); this.ctx.arc(cx, cy, this.cellSize/2 - 2, 0, 2 * Math.PI);
        const g = this.ctx.createRadialGradient(cx-3, cy-3, 2, cx, cy, 15);
        if (color === 1) { g.addColorStop(0, '#555'); g.addColorStop(1, '#000'); }
        else { g.addColorStop(0, '#fff'); g.addColorStop(1, '#ddd'); }
        this.ctx.fillStyle = g; this.ctx.fill();
    }

    handleInput(e) {
        if (this.isAIEnabled && this.currentColor === 2) return;
        const rect = this.canvas.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left - 30) / this.cellSize);
        const y = Math.round((e.clientY - rect.top - 30) / this.cellSize);
        this.attemptMove(x, y);
    }

    attemptMove(x, y, isAI = false) {
        if (x < 0 || x >= 19 || y < 0 || y >= 19 || this.board[y][x] !== 0) return false;
        
        const tempBoard = this.board.map(row => row.slice());
        tempBoard[y][x] = this.currentColor;
        let capturedStones = this.checkAndRemoveCaptures(x,
